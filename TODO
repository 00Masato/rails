todo:
- remove to_sql logic from array and hash, push it into a strategy
- string passthrough:
 :joins=>"INNER JOIN posts ON comments.post_id = posts.id"
 :conditions=>"(`posts`.author_id = 1)",
 :select=>"`comments`.*"
 :conditions=>"1 = 1"

- need adapters for this form:
 {:conditions=>["approved = ?", false]}
 {:conditions=>{:approved=>false}}
 {:conditions=>{"topics.approved"=>false}}
 {:conditions=>{:address=>#<Address:0x3489b3c @street="Funny Street", @country="Loony Land", @city="Scary Town">, "customers.name"=>"David1"}}
 
- need to_sql for ranges
 {:conditions=>{:id=>2..3}}
 
- orders need string pass through
 :order=>"developers.name desc, developers.id desc",

- orders need to be composable
- #bind in Attribute and Expression should be doing a descend?
- try to make aggration testing in join spec to be a bit more unit-like
- finish pending tests
- test relation, table reset
- cache expiry on write
  - rewrite of querycache test in light of this
- relation inclusion when given an array (1,2,3,4) should quote the elements using the appropriate quoting strategy taken from the attribute
  - descend on array, along with bind written in terms of it
- standardize quoting
  - use strings everywhere, not symbols ?
- "unit" test sql strategies
  - use real world examples, so they should be like a tutorial.
- rename the tion (Selection) classes so that words that don't end in tion don't seem inconsistent
- re-evaluate bind
- mock out database

done:
. Relation <=> Relation -> InnerJoinOperation
. Relation << Relation -> LeftOuterJoinOperation
. InnerJoinOperation.on(*Predicate) -> InnerJoinRelation
. LeftOuterJoinOperation.on(*Predicate) -> LeftOuterJoinRelation
. Relation[Symbol] -> Attribute
. Relation[Range] -> Relation
. Attribute == Attribute -> EqualityPredicate
. Attribute >= Attribute -> GreaterThanOrEqualToPredicate
. Relation.include?(Column) -> Predicate
. Relation.project(*Column) -> ProjectionRelation
. Relation.select(*Predicate) -> SelectionRelation
. Relation.order(*Column) -> OrderRelation
. #to_sql
. Remove Builder
. Namespace
. Audit SqlAlchemy for missing features
- Generalized denormalizations on any aggregation (count, yes, but also max, min, average)
- Remove operator overloading of << and <=> for joins. Make it just foo.join(bar) and foo.outer_join(bar).
- Remove operator overloading of == for predicates. make it a.equals(b) (note lack of question mark).
- hookup more predicates (=, <=, =>)
- get some basic aggregations working: users.project(user[:points].max)
- Alias Table Names
- When joining with any sort of aggregation, it needs to be a nested select
- get a value select working: users.project(users[:name], addresses.select(addresses[:user_id] == users[:id]).project(addresses[:id].count))
- Session
- sublimate values to deal with the fact that they must be quoted per engine
- clean-up singleton monstrosity
- extract hashing module
- hash custom matcher
- make session engine stuff follow laws of demeter - currently doing some odd method chaining? rethink who is responsible for what
  - session just calls execute, passing in a connection; by default it gets a connection from the relation.
- #strategy is now on value, attribute and relation; you must admit it's name is confusing given that e.g., relation already has a strategy (Sql::Relation) ... should it be called predicate strategy? operand1.to_sql(operand2.predicate) maybe prefer operand1.cast(operand2) or project or in light of
  - renamed to #format: operand1.format(operand2)
- rename sql strategies
