Performance testing Rails Applications
======================================

This guide covers the various ways of performance testing a Ruby on Rails application. By referring to this guide, you will be able to:

* Understand the various types of benchmarking and profiling metrics
* Generate performance/benchmarking tests
* Use GC patched Ruby binary to measure memory usage and object allocation
* Understand the information provided by Rails inside the log files
* Learn about various tools facilitating benchmarking and profiling

Performance testing is an integral part of the development cycle. It is very important that you don't make your end users wait for too long before the page is completely loaded. Ensuring a plesant browsing experience to the end users and cutting cost of unnecessary hardwares is important for any web application.

== Performance Test Cases ==

Rails performance tests are integration tests designed for benchmarking and profiling the test code. With performance tests, you can determine where your application's memory or speed problems are coming from, and get a more in-depth picture of those problems.

In a freshly generated Rails application, +test/performance/browsing_test.rb+ contains an example of a performance test:

[source, ruby]
----------------------------------------------------------------------------
require 'test_helper'
require 'performance_test_help'

# Profiling results for each test method are written to tmp/performance.
class BrowsingTest < ActionController::PerformanceTest
  def test_homepage
    get '/'
  end
end
----------------------------------------------------------------------------

The above example is a simple performance test case for profiling a GET request to the application's homepage.

=== Generating performance tests ===

Rails provides a generator called +performance_test+ for creating new performance tests:

[source, shell]
----------------------------------------------------------------------------
[lifo@null application (master)]$ script/generate performance_test homepage
----------------------------------------------------------------------------

This will generate +test/performance/homepage_test.rb+:

[source, ruby]
----------------------------------------------------------------------------
require 'test_helper'
require 'performance_test_help'

class HomepageTest < ActionController::PerformanceTest
  # Replace this with your real tests.
  def test_homepage
    get '/'
  end
end
----------------------------------------------------------------------------

Which you can modify to suit your needs.

=== Modes ===

Performance test cases can be run in two modes : Benchmarking and Profling.

==== Benchmarking ====

Benchmarking helps you find out how fast are your test cases. Each Test case is run +4 times+ in this mode. To run performance tests in benchmarking mode:

[source, shell]
----------------------------------------------------------------------------
$ rake test:benchmark
----------------------------------------------------------------------------

==== Profiling ====

Profiling helps introspect into your test cases and figure out which are the slow parts. Each Test case is run +1 time+ in this mode. To run performance tests in profiling mode:

[source, shell]
----------------------------------------------------------------------------
$ rake test:profile
----------------------------------------------------------------------------

=== Metrics ===

Benchmarking and profiling run performance test cases in various modes to help precisely figure out the where the problem lies.

==== Wall Time ====

Measures the real world time elapsed during the test run. It is affected by any other processes concurrently running on the system.

Mode : Benchmarking

==== Process Time ====

Measures the time taken by the process. It is unaffected by any other processes running concurrently on the same system. Hence, process time is likely to be constant for any given performance test, irrespective of the machine load.

Mode : Profiling

==== Memory ====

Measures the amount of memory used for the performance test case.

Mode : Benchmarking, Profiling [xref:gc[Requires GC Patched Ruby]]

==== Objects ====

Measures the number of objects allocated for the performance test case.

Mode : Benchmarking, Profiling [xref:gc[Requires GC Patched Ruby]]

==== GC Runs ====

Measures the number of times GC was invoked for the performance test case.

Mode : Benchmarking [xref:gc[Requires GC Patched Ruby]]

==== GC Time ====

Measures the amount of time spent in GC for the performance test case.

Mode : Benchmarking [xref:gc[Requires GC Patched Ruby]]

=== Understanding the output ===

Performance tests generate different outputs inside +tmp/performance+ directory based on the mode it is run in and the metric.

==== Benchmarking ====

In benchmarking mode, performance tests generate two types of outputs :

===== Command line =====

This is the primary form of output in benchmarking mode. Example :

[source, shell]
----------------------------------------------------------------------------
BrowsingTest#test_homepage (31 ms warmup)
           wall_time: 6 ms
              memory: 437.27 KB
             objects: 5514
             gc_runs: 0
             gc_time: 19 ms
----------------------------------------------------------------------------

===== CSV files =====

Performance tests results are also appended to +.csv+ files inside +tmp/performance/<Class>#<test>_<metric>.csv+ file. For example, running the default +BrowsingTest#test_homepage+ will generate following five files :

  - BrowsingTest#test_homepage_gc_runs.csv
  - BrowsingTest#test_homepage_gc_time.csv
  - BrowsingTest#test_homepage_memory.csv
  - BrowsingTest#test_homepage_objects.csv
  - BrowsingTest#test_homepage_wall_time.csv

As the results are appended to these files each time the performance tests are run in benchmarking mode, it enables you gather data over a sustainable period of time which can be very helpful with various performance analysis.

Sample output of +BrowsingTest#test_homepage_wall_time.csv + :

[source, shell]
----------------------------------------------------------------------------
measurement,created_at,app,rails,ruby,platform
0.00738224999999992,2009-01-08T03:40:29Z,,2.3.0.master.0744148,ruby-1.8.6.110,i686-darwin9.0.0
0.00755874999999984,2009-01-08T03:46:18Z,,2.3.0.master.0744148,ruby-1.8.6.110,i686-darwin9.0.0
0.00762099999999993,2009-01-08T03:49:25Z,,2.3.0.master.0744148,ruby-1.8.6.110,i686-darwin9.0.0
0.00603075000000008,2009-01-08T04:03:29Z,,2.3.0.master.0744148,ruby-1.8.6.111,i686-darwin9.1.0
0.00619899999999995,2009-01-08T04:03:53Z,,2.3.0.master.0744148,ruby-1.8.6.111,i686-darwin9.1.0
0.00755449999999991,2009-01-08T04:04:55Z,,2.3.0.master.0744148,ruby-1.8.6.110,i686-darwin9.0.0
0.00595999999999997,2009-01-08T04:05:06Z,,2.3.0.master.0744148,ruby-1.8.6.111,i686-darwin9.1.0
0.00740450000000004,2009-01-09T03:54:47Z,,2.3.0.master.859e150,ruby-1.8.6.110,i686-darwin9.0.0
0.00603150000000008,2009-01-09T03:54:57Z,,2.3.0.master.859e150,ruby-1.8.6.111,i686-darwin9.1.0
0.00771250000000012,2009-01-09T15:46:03Z,,2.3.0.master.859e150,ruby-1.8.6.110,i686-darwin9.0.0
----------------------------------------------------------------------------

==== Profiling ====

===== Command line =====

This is the very basic form of output in profiling mode. Example :

[source, shell]
----------------------------------------------------------------------------
BrowsingTest#test_homepage (58 ms warmup)
        process_time: 63 ms
              memory: 832.13 KB
             objects: 7882
----------------------------------------------------------------------------

===== Flat =====

Flat output shows the total amount of time spent in each method. http://ruby-prof.rubyforge.org/files/examples/flat_txt.html[Check ruby prof documentation for a better explaination].

===== Graph =====

Graph output shows how long each method takes to run, which methods call it and which methods it calls. http://ruby-prof.rubyforge.org/files/examples/graph_txt.html[Check ruby prof documentation for a better explaination].

===== Tree =====

Tree output is profiling information in calltree format for use by kcachegrind and similar tools.

[[gc]]
=== Installing GC Patched Ruby ===

To get the best from Rails performance test cases, you need to build a special Ruby binary with some super powers - GC patch for measuring GC Runs/Time and memory/object allocation profiling. This process is very straight forward. If you've never compiled a Ruby binary before, you can follow the following steps to build a ruby binary inside your home directory:

==== Instllation ====

Compile Ruby and apply this http://rubyforge.org/tracker/download.php/1814/7062/17676/3291/ruby186gc.patch[GC Patch]:

==== Download and Extract ====

[source, shell]
----------------------------------------------------------------------------
[lifo@null ~]$ mkdir rubygc
[lifo@null ~]$ wget <download the latest stable ruby from ftp://ftp.ruby-lang.org/pub/ruby>
[lifo@null ~]$ tar -xzvf <ruby-version.tar.gz>
[lifo@null ~]$ cd <ruby-version>
----------------------------------------------------------------------------

==== Apply the patch ====

[source, shell]
----------------------------------------------------------------------------
[lifo@null ruby-version]$ curl http://rubyforge.org/tracker/download.php/1814/7062/17676/3291/ruby186gc.patch | patch -p0
----------------------------------------------------------------------------

==== Configure and Install ====

The following will install ruby in your home directory's +/rubygc+ directory. Make sure to replace +<homedir>+ with a full patch to your actual home directory.

[source, shell]
----------------------------------------------------------------------------
[lifo@null ruby-version]$ ./configure --prefix=/<homedir>/rubygc
[lifo@null ruby-version]$ make && make install
----------------------------------------------------------------------------

==== Prepare aliases ====

For convenience, add the following lines in your ~/.profile after replacing <username> with your :

----------------------------------------------------------------------------
alias gcruby='~/rubygc/bin/ruby'
alias gcrake='~/rubygc/bin/rake'
alias gcgem='~/rubygc/bin/gem'
alias gcirb='~/rubygc/bin/irb'
alias gcrails='~/rubygc/bin/rails'
----------------------------------------------------------------------------

==== Install rubygems and some basic gems ====

Download http://rubyforge.org/projects/rubygems[Rubygems] and install it from source. Rubygem's README file should have necessary installation instructions.

Additionally, installa the following gems :

  * +rake+
  * +rails+
  * +ruby-prof+
  * +rack+
  * +mysql+

If installing +mysql+ fails, you can try to install it manually:

----------------------------------------------------------------------------
[lifo@null mysql]$ gcruby extconf.rb --with-mysql-config
[lifo@null mysql]$ make && make install
----------------------------------------------------------------------------

And you're ready to go. Don't forget to use +gcruby+ and +gcrake+ aliases when running performance tests!

== Helper methods ==

Rails provides various helper methods inside Active Record, Action Controller and Action View to measure the time taken by a specific code. The method is called +benchmark()+ in all three components.

=== Model ===

[source, ruby]
----------------------------------------------------------------------------
Project.benchmark("Creating project") do
  project = Project.create("name" => "stuff")
  project.create_manager("name" => "David")
  project.milestones << Milestone.find(:all)
end
----------------------------------------------------------------------------

The above code benchmarks the multiple statments enclosed inside +Project.benchmark("Creating project") do..end+ block and prints the results to the log file. The statement inside log files will look like:

[source, ruby]
----------------------------------------------------------------------------
Creating projectem (185.3ms)
----------------------------------------------------------------------------

Please refer to http://api.rubyonrails.com/classes/ActiveRecord/Base.html#M001336[API docs] for optional options to +benchmark()+

=== Controller ===

Similarly, you could use this helper method inside http://api.rubyonrails.com/classes/ActionController/Benchmarking/ClassMethods.html#M000715[controllers] ( Note that it's a class method here ):

[source, ruby]
----------------------------------------------------------------------------
def process_projects
  self.class.benchmark("Processing projects") do
    Project.process(params[:project_ids])
    Project.update_cached_projects
  end
end
----------------------------------------------------------------------------

=== View ===

And in http://api.rubyonrails.com/classes/ActionController/Benchmarking/ClassMethods.html#M000715[views]:

[source, ruby]
----------------------------------------------------------------------------
<% benchmark("Showing projects partial") do %>
  <%= render :partial => @projects %>
<% end %>
----------------------------------------------------------------------------

== Request Logging ==

Rails log files containt basic but very useful information about the time taken to serve each request. A typical log entry looks something like :

[source, ruby]
----------------------------------------------------------------------------
Processing ItemsController#index (for 127.0.0.1 at 2009-01-08 03:06:39) [GET]
Rendering template within layouts/items
Rendering items/index
Completed in 5ms (View: 2, DB: 0) | 200 OK [http://0.0.0.0/items]
----------------------------------------------------------------------------

For this section, we're only interested in the last line from that log entry:

[source, ruby]
----------------------------------------------------------------------------
Completed in 5ms (View: 2, DB: 0) | 200 OK [http://0.0.0.0/items]
----------------------------------------------------------------------------

This data is fairly straight forward to understand. Rails uses millisecond(ms) as the metric to measures the time taken. The complete request spent 5 ms inside Rails, out of which 2 ms were spent rendering views and none was spent communication with the database. It's safe to assume that the remaining 3 ms were spent inside the controller. 

Michael Koziarski has an http://www.therailsway.com/2009/1/6/requests-per-second[interesting blog post] explaining the importance of using milliseconds as the metric.

== Other Profiling Tools ==

* http://www.hpl.hp.com/research/linux/httperf/[httperf]
* http://rails-analyzer.rubyforge.org/[Rails Analyzer]
* http://www.flyingmachinestudios.com/projects/[Palmist]

== Commercial products dedicated to Rails Perfomance ==
* http://www.newrelic.com[New Relic]
* http://www.fiveruns.com[Fiveruns]
* http://scoutapp.com[Scout]

== Changelog ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/4[Lighthouse ticket]

* January 9, 2009: Rewrite by Pratik
* October 17, 2008: First revision by Pratik
* September 6, 2008: Initial version by Matthew Bergman
