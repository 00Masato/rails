todo:
- clarify distinction between engine and connection: an engine is a connection pool, plus the quoting operations
- #relation is now on scalar, attribute and relation; you must admit it's name is confusing given that e.g., relation already has a strategy (Sql::Relation) ... should it be called predicate strategy? operand1.to_sql(operand2.predicate) maybe prefer operand1.cast(operand2) or project or in light of
- clean up integration tests in join - i find the aggregate stuff too integrationy; unit testing would be better
- test relation, table reset
- cache expiry on write
  - rewrite of querycache test in light of this
- relation inclusion when given an array (1,2,3,4) should quote the elements using the appropriate quoting strategy taken from the attribute
  - descend on array, along with bind written in terms of it
- standardize quoting
  - use strings everywhere, not symbols ?
- rename and test sql strategies
  - the parallel names are confusing since it's not obvious what's what. plus, we lack unit tests; the biggest complaint is a lack of clarity concerning what purpose these serve in the system. Unit tests wont illustrate much unless we use concrete examples.
- rename the tion (Selection) classes so that words that don't end in tion don't seem inconsistent
- re-evaluate bind

done:
. Relation <=> Relation -> InnerJoinOperation
. Relation << Relation -> LeftOuterJoinOperation
. InnerJoinOperation.on(*Predicate) -> InnerJoinRelation
. LeftOuterJoinOperation.on(*Predicate) -> LeftOuterJoinRelation
. Relation[Symbol] -> Attribute
. Relation[Range] -> Relation
. Attribute == Attribute -> EqualityPredicate
. Attribute >= Attribute -> GreaterThanOrEqualToPredicate
. Relation.include?(Column) -> Predicate
. Relation.project(*Column) -> ProjectionRelation
. Relation.select(*Predicate) -> SelectionRelation
. Relation.order(*Column) -> OrderRelation
. #to_sql
. Remove Builder
. Namespace
. Audit SqlAlchemy for missing features
- Generalized denormalizations on any aggregation (count, yes, but also max, min, average)
- Remove operator overloading of << and <=> for joins. Make it just foo.join(bar) and foo.outer_join(bar).
- Remove operator overloading of == for predicates. make it a.equals(b) (note lack of question mark).
- hookup more predicates (=, <=, =>)
- get some basic aggregations working: users.project(user[:points].max)
- Alias Table Names
- When joining with any sort of aggregation, it needs to be a nested select
- get a scalar select working: users.project(users[:name], addresses.select(addresses[:user_id] == users[:id]).project(addresses[:id].count))
- Session
- sublimate scalars to deal with the fact that they must be quoted per engine
- clean-up singleton monstrosity
- extract hashing module
- hash custom matcher
- make session engine stuff follow laws of demeter - currently doing some odd method chaining? rethink who is responsible for what
  - session just calls execute, passing in a connection; by default it gets a connection from the relation.
